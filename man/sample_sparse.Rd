% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sample_sparse.R, R/undirected_erdos_renyi.R,
%   R/undirected_sbm.R
\name{sample_sparse}
\alias{sample_sparse}
\alias{sample_sparse.undirected_factor_model}
\alias{sample_sparse.directed_factor_model}
\alias{sample_sparse.undirected_erdos_renyi}
\title{Sample a random dot product graph as a sparse Matrix}
\usage{
sample_sparse(factor_model, ..., poisson_edges = TRUE, allow_self_loops = TRUE)

\method{sample_sparse}{undirected_factor_model}(factor_model, ..., poisson_edges = TRUE, allow_self_loops = TRUE)

\method{sample_sparse}{directed_factor_model}(factor_model, ..., poisson_edges = TRUE, allow_self_loops = TRUE)

\method{sample_sparse}{undirected_erdos_renyi}(
  factor_model,
  ...,
  poisson_edges = FALSE,
  allow_self_loops = TRUE
)

\method{sample_sparse}{undirected_erdos_renyi}(
  factor_model,
  ...,
  poisson_edges = FALSE,
  allow_self_loops = TRUE
)
}
\arguments{
\item{factor_model}{A \code{\link[=directed_factor_model]{directed_factor_model()}} or
\code{\link[=undirected_factor_model]{undirected_factor_model()}}.}

\item{...}{Ignored. Do not use.}

\item{poisson_edges}{Logical indicating whether or not
multiple edges are allowed to form between a pair of
nodes. Defaults to \code{TRUE}. When \code{FALSE}, sampling proceeds
as usual, and duplicate edges are removed afterwards.
See Section 2.3 of Rohe et al (2017) for additional
details.}

\item{allow_self_loops}{Logical indicating whether or not
nodes should be allowed to form edges with themselves.
Defaults to \code{TRUE}. When \code{FALSE}, sampling proceeds
as usual, and self-loops are removed afterwards.}
}
\value{
For undirected factor models, a sparse
\code{\link[Matrix:Matrix]{Matrix::Matrix()}} of class \code{dsCMatrix}. In particular,
this means the \code{Matrix} object (1) has
double data type, (2) is symmetric, and (3) is in
column compressed storage format.

For directed factor models, a sparse
\code{\link[Matrix:Matrix]{Matrix::Matrix()}} of class \code{dgCMatrix}. This means
the \code{Matrix} object (1) has double data type,
(2) in \emph{not} symmetric, and (3) is in column
compressed storage format.

To reiterate: for undirected graphs, you will get
a symmetric matrix. For directed graphs, you will
get a general sparse matrix.
}
\description{
There are two steps to using the \code{fastRG} package. First,
you must parameterize a random dot product graph by
specifying its expected adjacency matrix. Use functions such as
\code{\link[=dcsbm]{dcsbm()}}, \code{\link[=sbm]{sbm()}}, etc, to perform this specification.
Then, use \code{\link[=sample_sparse]{sample_sparse()}} to generate a random graph,
represented as a \code{\link[Matrix:Matrix]{Matrix::Matrix()}}, with that expectation.
}
\details{
This function implements the \code{fastRG} algorithm as
described in Rohe et al (2017). Please see the paper
(which is short and open access!!) for details.
}
\examples{

set.seed(27)

##### undirected examples ----------------------------

n <- 1000
k <- 5

X <- matrix(rpois(n = n * k, 1), nrow = n)
S <- matrix(runif(n = k * k, 0, .1), nrow = k)

ufm <- undirected_factor_model(
  X, S,
  expected_density = 0.1
)

ufm

### sampling graphs as edgelists ----------------------

edgelist <- sample_edgelist(ufm)
edgelist

### sampling graphs as sparse matrices ----------------

A <- sample_sparse(ufm)

inherits(A, "dsCMatrix")  # TRUE
class(A[2, 1])            # "numeric" -- i.e. A has double data type
isSymmetric(A)            # TRUE

B <- sample_sparse(ufm, poisson_edges = FALSE)

inherits(B, "dsCMatrix")  # TRUE
isSymmetric(B)            # TRUE

### sampling graphs as igraph graphs ------------------

sample_igraph(ufm)

### sampling graphs as tidygraph graphs ---------------

sample_tidygraph(ufm)

sample_tidygraph(ufm, poisson_edges = FALSE)

##### directed examples ----------------------------

n2 <- 10000

k1 <- 5
k2 <- 3

d <- 5000

X <- matrix(rpois(n = n2 * k1, 1), nrow = n2)
S <- matrix(runif(n = k1 * k2, 0, .1), nrow = k1, ncol = k2)
Y <- matrix(rexp(n = k2 * d, 1), nrow = d)

fm <- directed_factor_model(X, S, Y, expected_in_degree = 50)
fm

### sampling graphs as edgelists ----------------------

edgelist2 <- sample_edgelist(fm)
edgelist2

### sampling graphs as sparse matrices ----------------

A2 <- sample_sparse(fm)

inherits(A2, "dgCMatrix") # TRUE
isSymmetric(A2)           # FALSE

B2 <- sample_sparse(fm, poisson_edges = FALSE)

inherits(B2, "dgCMatrix")  # TRUE
isSymmetric(B2)            # TRUE

### sampling graphs as igraph graphs ------------------

sample_igraph(fm)

### sampling graphs as tidygraph graphs ---------------

sample_tidygraph(fm)

sample_tidygraph(fm, poisson_edges = FALSE)

}
\references{
Rohe, Karl, Jun Tao, Xintian Han, and Norbert Binkiewicz. 2017.
"A Note on Quickly Sampling a Sparse Matrix with Low Rank Expectation."
Journal of Machine Learning Research; 19(77):1-13, 2018.
\url{http://www.jmlr.org/papers/v19/17-128.html}
}
\seealso{
Other samplers: 
\code{\link{sample_edgelist.matrix}()},
\code{\link{sample_edgelist}()},
\code{\link{sample_igraph}()},
\code{\link{sample_tidygraph}()}
}
\concept{samplers}
