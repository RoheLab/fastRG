% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/fastRG.R
\name{fastRG}
\alias{fastRG}
\title{Sample a Random Dot Product Graph (RDPG)}
\usage{
fastRG(
  X,
  S,
  Y = NULL,
  avg_deg = NULL,
  simple = FALSE,
  poisson_edges = TRUE,
  directed = TRUE,
  allow_self_loops = TRUE,
  return_edge_list = FALSE
)
}
\arguments{
\item{X}{An \code{n} by \code{k_1} matrix.}

\item{S}{A \code{k_1} by \code{k_2} matrix.}

\item{Y}{A \code{d} by \code{k_2} matrix. Defaults to \code{X}.}

\item{avg_deg}{When specified, rescales parameter such that the
expected degree is \code{avg_deg} in the Poisson multi-graph. When
\code{poisson_edges = FALSE}, the resulting graph will have lower a
average degree than \code{avg_deg} due to lack of multi-edges. When
the graph is sparse, the expected number of edges for the Poisson
multi-graph and Bernoulli graph are nearly the
same. Defaults to \code{NULL}, such that no scaling occurs.}

\item{simple}{When \code{TRUE}, indicates that you want to work with undirected
graphs where self-loops and multi-edges are prohibited. Accomplishes
this by setting \code{directed = FALSE}, \code{allow_self_loops = FALSE}, and
\code{poisson_edges = FALSE}, and then ignoring arguments \code{directed},
\code{allow_self_loops} and \code{poisson_edges}. Defaults to \code{FALSE}.}

\item{poisson_edges}{Logical indicating whether or not multi-edges are
allowed. Defaults to \code{TRUE}, which keeps multi-edges and produces
a multi-graph. When \code{FALSE}, only single edges are allowed, resulting
in a graph. See \strong{details} for some additional comments. Effected by
\code{simple} argument.}

\item{directed}{Logical indicating whether or not the graph should be
directed. Default is \code{directed = TRUE}. When \code{directed = FALSE},
symmetrizes \code{S} internally. When \code{X = Y} (which is the default when
no \code{Y} is specified), this results in a symmetric adjacency matrix
as output. When \code{avg_deg} is specified and the desired graph is directed,
the average degree scaling is on the out-degree of each node (or the
row sums if you prefer to think in terms of the adjacency matrix).
Effected by the \code{simple} argument.}

\item{allow_self_loops}{Logical indicating whether edges are allowed from
a node back to itself. Defaults to \code{TRUE}. When \code{FALSE}, sampling
proceeds normally, and then self-loops are removed after sampling
is completed. Effected by the \code{simple} argument.}

\item{return_edge_list}{Logical indicating whether to return an edgelist
rather than an adjacency matrix. Defaults to \code{FALSE}.}
}
\value{
A random Poisson (or Bernoulli) dot product graph. By default,
returns a \code{\link[Matrix:sparseMatrix]{Matrix::sparseMatrix()}} in CSC format (i.e. of abstract
class \code{CsparseMatrix}). When the graph is undirected, the \code{sparseMatrix}
will also be symmetric.

If \code{return_edge_list = TRUE}, instead returns the graph as an edgelist
in matrix format, with contains two columns called \code{from} and \code{to}.
The \code{from} column contains the index of the outgoing edge,
and the \code{to} column contains the index of the incoming edge.
}
\description{
We \emph{strongly} advise that you always set \code{avg_deg}, as it is
easy to request very large and dense graphs without this scaling.
}
\details{
TODO: clean up the following:

This uses a poisson approximation to the binomial...

Let \eqn{M ~ Poisson(\sum_{uv} \lambda_{uv})} be the number of edges.
If allow_self_loops == F, then the code uses the approximation
\deqn{
    Poisson(\lambda_{ij})
    \approx Binomial(M, \lambda_{ij}/\sum_{uv}\lambda_{uv})
  }

This approximation is good when total edges is ~n or larger and max
\eqn{\lambda_{ij}} ~constant or smaller. this thresholds each edge;
multiple edges are replaced by single edges.
}
\examples{

set.seed(372)

n <- 10000
d <- 1000

k1 <- 5
k2 <- 3

X <- matrix(rpois(n = n * k1, 1), nrow = n)
S <- matrix(runif(n = k1 * k2, 0, .1), nrow = k1)
Y <- matrix(rpois(n = d * k2, 1), nrow = d)

# all the bells and whistles, return graph as a matrix
A <- fastRG(X, S, Y, avg_deg = 10)

# expected edge count, degree and density without scaling
expected(X, S, Y)

# get the graph as an edge list
edge_list <- fastRG(X, S, Y, return_edge_list = TRUE)

### some symmetric graphs

S2 <- matrix(runif(n = k1 * k1, 0, .1), nrow = k1)

# a binary, symmetric graph with no self-loops
B <- fastRG(X, S2, avg_deg = 10, simple = TRUE)

# another symmetric graph
C <- fastRG(X, S2, avg_deg = 20, directed = FALSE)

# expected edge count, degree and density without scaling
expected(X, S2)

}
\references{
Rohe, Karl, Jun Tao, Xintian Han, and Norbert Binkiewicz. 2017.
“A Note on Quickly Sampling a Sparse Matrix with Low Rank Expectation.”
Journal of Machine Learning Research; 19(77):1-13, 2018.
\url{http://www.jmlr.org/papers/v19/17-128.html}
}
